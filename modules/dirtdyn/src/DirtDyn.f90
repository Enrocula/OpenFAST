!**********************************************************************************************************************************
!> ## DirtDyn
!! The DirtDyn and DirtDyn_Types modules make up a template for creating user-defined calculations in the FAST Modularization
!! Framework. DirtDyn_Types will be auto-generated by the FAST registry program, based on the variables specified in the
!! DirtDyn_Registry.txt file.
!!
!! This template file contains comments in the style required for Doxygen, and it contains methods for handling errors.
!!
!! "DirtDyn" should be replaced with the name of your module. Example: ElastoDyn \n
!! "DirtDyn" (in DirtDyn_*) should be replaced with the module name or an abbreviation of it. Example: ED
! ..................................................................................................................................
!! ## LICENSING
!! Copyright (C) 2012-2013, 2015-2016  National Renewable Energy Laboratory
!!
!!    This file is part of DirtDyn.
!!
!! Licensed under the Apache License, Version 2.0 (the "License");
!! you may not use this file except in compliance with the License.
!! You may obtain a copy of the License at
!!
!!     http://www.apache.org/licenses/LICENSE-2.0
!!
!! Unless required by applicable law or agreed to in writing, software
!! distributed under the License is distributed on an "AS IS" BASIS,
!! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!! See the License for the specific language governing permissions and
!! limitations under the License.
!**********************************************************************************************************************************
MODULE DirtDyn

   USE DirtDyn_Types
   USE NWTC_Library
   USE REDWINinterface

   IMPLICIT NONE

   PRIVATE

   TYPE(ProgDesc), PARAMETER :: DirtDyn_Ver = ProgDesc( 'DirtDyn', 'v0.01.00', '99-Feb-2020' ) !< module date/version information

      ! ..... Public Subroutines ...................................................................................................
   PUBLIC :: DirtDyn_Init                           !  Initialization routine
   PUBLIC :: DirtDyn_End                            !  Ending routine (includes clean up)
   PUBLIC :: DirtDyn_UpdateStates                   !  Loose coupling routine for solving for constraint states, integrating
   PUBLIC :: DirtDyn_CalcOutput                     !  Routine for computing outputs

!NOTE: these are placeholders for now.
!!!   PUBLIC :: DirtDyn_CalcConstrStateResidual        !  Tight coupling routine for returning the constraint state residual
!!!   PUBLIC :: DirtDyn_CalcContStateDeriv             !  Tight coupling routine for computing derivatives of continuous states
!!!   PUBLIC :: DirtDyn_UpdateDiscState                !  Tight coupling routine for updating discrete states
!!!   PUBLIC :: DirtDyn_JacobianPInput                 !  Routine to compute the Jacobians of the output (Y), continuous- (X), discrete- (Xd), and constraint-state (Z) functions all with respect to the inputs (u)
!!!   PUBLIC :: DirtDyn_JacobianPContState             !  Routine to compute the Jacobians of the output (Y), continuous- (X), discrete- (Xd), and constraint-state (Z) functions all with respect to the continuous states (x)
!!!   PUBLIC :: DirtDyn_JacobianPDiscState             !  Routine to compute the Jacobians of the output (Y), continuous- (X), discrete- (Xd), and constraint-state (Z) functions all with respect to the discrete states (xd)
!!!   PUBLIC :: DirtDyn_JacobianPConstrState           !  Routine to compute the Jacobians of the output (Y), continuous- (X), discrete- (Xd), and constraint-state (Z) functions all with respect to the constraint states (z)
!!!   PUBLIC :: DirtDyn_GetOP                          !  Routine to get the operating-point values for linearization (from data structures to arrays)

contains

!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!> This routine is called at the start of the simulation to perform initialization steps.
!! The parameters are set here and not changed during the simulation.
!! The initial states and initial guess for the input are defined.
subroutine DirtDyn_Init( InitInp, u, p, x, xd, z, OtherState, y, m, Interval, InitOut, ErrStat, ErrMsg )

   type(DirtD_InitInputType),         intent(in   )  :: InitInp     !< Input data for initialization routine
   type(DirtD_InputType),             intent(  out)  :: u           !< An initial guess for the input; input mesh must be defined
   type(DirtD_ParameterType),         intent(  out)  :: p           !< Parameters
   type(DirtD_ContinuousStateType),   intent(  out)  :: x           !< Initial continuous states
   type(DirtD_DiscreteStateType),     intent(  out)  :: xd          !< Initial discrete states
   type(DirtD_ConstraintStateType),   intent(  out)  :: z           !< Initial guess of the constraint states
   type(DirtD_OtherStateType),        intent(  out)  :: OtherState  !< Initial other states (logical, etc)
   type(DirtD_OutputType),            intent(  out)  :: y           !< Initial system outputs
   type(DirtD_MiscVarType),           intent(  out)  :: m           !< Misc variables for optimization (not copied in glue code)
   real(DbKi),                        intent(inout)  :: Interval    !< Coupling interval in seconds
   type(DirtD_InitOutputType),        intent(  out)  :: InitOut     !< Output for initialization routine
   integer(IntKi),                    intent(  out)  :: ErrStat     !< Error status of the operation
   character(*),                      intent(  out)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None

      ! local variables
   integer(IntKi)                                    :: NumOuts     ! number of outputs; would probably be in the parameter type
   integer(IntKi)                                    :: ErrStat2    ! local error status
   character(ErrMsgLen)                              :: ErrMsg2     ! local error message
   character(*), parameter                           :: RoutineName = 'DirtDyn_Init'
   type(DirtD_InputFile)                             :: InputFileData   !< Data stored in the module's input file

      ! Initialize variables
   ErrStat = ErrID_None
   ErrMsg  = ""
   NumOuts = 2

      ! Initialize the NWTC Subroutine Library
   call NWTC_Init( )

      ! Display the module information
   call DispNVD( DirtDyn_Ver )


      ! Define parameters here:
   p%DT  = Interval

      ! Define initial system states here:
   x%DummyContState           = 0.0_ReKi
   xd%DummyDiscState          = 0.0_ReKi
   z%DummyConstrState         = 0.0_ReKi
   OtherState%DummyOtherState = 0.0_ReKi

      ! Define initial guess for the system inputs here:
   u%DummyInput = 0.0_ReKi

!FIXME: Develop a list of outputs, and set that up somewhere.
      ! Define system output initializations (set up mesh) here:
   call AllocAry( y%WriteOutput, NumOuts, 'WriteOutput', ErrStat2, ErrMsg2 )
      call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName) ! set return error status based on local (concatenate errors)
      if (ErrStat >= AbortErrLev) return        ! if there are local variables that need to be deallocated, do so before early return

   y%DummyOutput = 0
   y%WriteOutput = 0

      ! Define initialization-routine output here:
   call AllocAry(InitOut%WriteOutputHdr,NumOuts,'WriteOutputHdr',ErrStat2,ErrMsg2); call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
   call AllocAry(InitOut%WriteOutputUnt,NumOuts,'WriteOutputUnt',ErrStat2,ErrMsg2); call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
      if (ErrStat >= AbortErrLev) return        ! if there are local variables that need to be deallocated, do so before early return

   InitOut%WriteOutputHdr = (/ 'Time   ', 'Column2' /)
   InitOut%WriteOutputUnt = (/ '(s)',     '(-)'     /)


   if (InitInp%Linearize) then

      ! If the module does not implement the four Jacobian routines at the end of this template, or the module cannot
      ! linearize with the features that are enabled, stop the simulation if InitInp%Linearize is true.

      CALL SetErrStat( ErrID_Fatal, 'DirtDyn cannot perform linearization analysis.', ErrStat, ErrMsg, RoutineName)

      ! Otherwise, if the module does allow linearization, return the appropriate Jacobian row/column names and rotating-frame flags here:
      ! Allocate and set these variables: InitOut%LinNames_y, InitOut%LinNames_x, InitOut%LinNames_xd, InitOut%LinNames_z, InitOut%LinNames_u
      ! Allocate and set these variables: InitOut%RotFrame_y, InitOut%RotFrame_x, InitOut%RotFrame_xd, InitOut%RotFrame_z, InitOut%RotFrame_u

   end if

!FIXME: quick hack for setup call
!FIXME: add input file parsing
InputFileData%DLL_ProcName = 'INTERFACEFOUNDATION'          ! The name of the procedure in the DLL that will be called.
InputFileData%DLL_FileName = 'REDWINmodel1-2.0_x86.dll'     ! 32 bit version for model 1
m%dll_data%PROPSfile = 'Props.txt'
m%dll_data%LDISPfile = 'LoadDisplacement.txt'
m%dll_data%IDtask = 1

   ! Initialize the DLL
   call REDWINinterface_Init(u,p,m,y,InputFileData, ErrStat2, ErrMsg2)
      call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)

end subroutine DirtDyn_Init


!----------------------------------------------------------------------------------------------------------------------------------
!> This routine is called at the end of the simulation.
subroutine DirtDyn_End( u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg )

   type(DirtD_InputType),             intent(inout)  :: u           !< System inputs
   type(DirtD_ParameterType),         intent(inout)  :: p           !< Parameters
   type(DirtD_ContinuousStateType),   intent(inout)  :: x           !< Continuous states
   type(DirtD_DiscreteStateType),     intent(inout)  :: xd          !< Discrete states
   type(DirtD_ConstraintStateType),   intent(inout)  :: z           !< Constraint states
   type(DirtD_OtherStateType),        intent(inout)  :: OtherState  !< Other states
   type(DirtD_OutputType),            intent(inout)  :: y           !< System outputs
   type(DirtD_MiscVarType),           intent(inout)  :: m           !< Misc variables for optimization (not copied in glue code)
   integer(IntKi),                    intent(  out)  :: ErrStat     !< Error status of the operation
   character(*),                      intent(  out)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None

      ! local variables
   integer(IntKi)                                    :: ErrStat2    ! local error status
   character(ErrMsgLen)                              :: ErrMsg2     ! local error message
   character(*), parameter                           :: RoutineName = 'DirtDyn_End'

      ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ""

      !! Place any last minute operations or calculations here:
   if (p%UseREDWINinterface) then
      call REDWINinterface_End( u, p, m, ErrStat, ErrMsg )
   endif

      !! Close files here (but because of checkpoint-restart capability, it is not recommended to have files open during the simulation):

      !! Destroy the input data:
   call DirtD_DestroyInput(      u,          ErrStat2,ErrMsg2);   call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)

      !! Destroy the parameter data:
   call DirtD_DestroyParam(      p,          ErrStat2,ErrMsg2);   call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)

      !! Destroy the state data:
   call DirtD_DestroyContState(  x,          ErrStat2,ErrMsg2);   call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
   call DirtD_DestroyDiscState(  xd,         ErrStat2,ErrMsg2);   call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
   call DirtD_DestroyConstrState(z,          ErrStat2,ErrMsg2);   call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
   call DirtD_DestroyOtherState( OtherState, ErrStat2,ErrMsg2);   call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)

      !! Destroy the output data:
   call DirtD_DestroyOutput( y, ErrStat2, ErrMsg2 ); call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)

      !! Destroy the misc data:
   call DirtD_DestroyMisc( m, ErrStat2, ErrMsg2 ); call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)

end subroutine DirtDyn_End


!----------------------------------------------------------------------------------------------------------------------------------
!> This is a loose coupling routine for solving constraint states, integrating continuous states, and updating discrete and other
!! states. Continuous, constraint, discrete, and other states are updated to values at t + Interval.
subroutine DirtDyn_UpdateStates( t, n, Inputs, InputTimes, p, x, xd, z, OtherState, m, ErrStat, ErrMsg )
   real(DbKi),                         intent(in   ) :: t               !< Current simulation time in seconds
   integer(IntKi),                     intent(in   ) :: n               !< Current step of the simulation: t = n*Interval
   type(DirtD_InputType),              intent(inout) :: Inputs(:)       !< Inputs at InputTimes (output from this routine only
                                                                        !!  because of record keeping in routines that copy meshes)
   real(DbKi),                         intent(in   ) :: InputTimes(:)   !< Times in seconds associated with Inputs
   type(DirtD_ParameterType),          intent(in   ) :: p               !< Parameters
   type(DirtD_ContinuousStateType),    intent(inout) :: x               !< Input: Continuous states at t;
                                                                        !!   Output: Continuous states at t + Interval
   type(DirtD_DiscreteStateType),      intent(inout) :: xd              !< Input: Discrete states at t;
                                                                        !!   Output: Discrete states at t + Interval
   type(DirtD_ConstraintStateType),    intent(inout) :: z               !< Input: Constraint states at t;
                                                                        !!   Output: Constraint states at t + Interval
   type(DirtD_OtherStateType),         intent(inout) :: OtherState      !< Other states: Other states at t;
                                                                        !!   Output: Other states at t + Interval
   type(DirtD_MiscVarType),            intent(inout) :: m               !<  Misc variables for optimization (not copied in glue code)
   integer(IntKi),                     intent(  out) :: ErrStat         !< Error status of the operation
   character(*),                       intent(  out) :: ErrMsg          !< Error message if ErrStat /= ErrID_None

      ! Local variables
   type(DirtD_ContinuousStateType)                   :: dxdt            ! Continuous state derivatives at t
   type(DirtD_DiscreteStateType)                     :: xd_t            ! Discrete states at t (copy)
   type(DirtD_ConstraintStateType)                   :: z_Residual      ! Residual of the constraint state functions (Z)
   type(DirtD_InputType)                             :: u               ! Instantaneous inputs
   integer(IntKi)                                    :: ErrStat2        ! local error status
   character(ErrMsgLen)                              :: ErrMsg2         ! local error message
   character(*), parameter                           :: RoutineName = 'DirtDyn_UpdateStates'

      ! Initialize variables
   ErrStat   = ErrID_None           ! no error has occurred
   ErrMsg    = ""

   ! This subroutine contains an example of how the states could be updated. Developers will
   ! want to adjust the logic as necessary for their own situations.

      ! Get the inputs at time t, based on the array of values sent by the glue code:
   ! before calling ExtrapInterp routine, memory in u must be allocated; we can do that with a copy:
   call DirtD_CopyInput( Inputs(1), u, MESH_NEWCOPY, ErrStat2, ErrMsg2 )
      call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()       ! to avoid memory leaks, we have to destroy the local variables that may have allocatable arrays or meshes
         return
      end if

   call DirtD_Input_ExtrapInterp( Inputs, InputTimes, u, t, ErrStat2, ErrMsg2 )
      call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
      if ( ErrStat >= AbortErrLev ) then
         call cleanup()
         return
      end if

      ! Destroy local variables before returning
   call cleanup()

contains
   subroutine cleanup()
      call DirtD_DestroyInput(       u,          ErrStat2, ErrMsg2)
      call DirtD_DestroyConstrState( Z_Residual, ErrStat2, ErrMsg2)
      call DirtD_DestroyContState(   dxdt,       ErrStat2, ErrMsg2)
      call DirtD_DestroyDiscState(   xd_t,       ErrStat2, ErrMsg2)
   end subroutine cleanup
end subroutine DirtDyn_UpdateStates


!----------------------------------------------------------------------------------------------------------------------------------
!> This is a routine for computing outputs, used in both loose and tight coupling.
subroutine DirtDyn_CalcOutput( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg )

   real(DbKi),                        intent(in   )  :: t           !< Current simulation time in seconds
   type(DirtD_InputType),             intent(in   )  :: u           !< Inputs at t
   type(DirtD_ParameterType),         intent(in   )  :: p           !< Parameters
   type(DirtD_ContinuousStateType),   intent(in   )  :: x           !< Continuous states at t
   type(DirtD_DiscreteStateType),     intent(in   )  :: xd          !< Discrete states at t
   type(DirtD_ConstraintStateType),   intent(in   )  :: z           !< Constraint states at t
   type(DirtD_OtherStateType),        intent(in   )  :: OtherState  !< Other states at t
   type(DirtD_MiscVarType),           intent(inout)  :: m           !< Misc variables for optimization (not copied in glue code)
   type(DirtD_OutputType),            intent(inout)  :: y           !< Outputs computed at t (Input only so that mesh con-
                                                                     !!   nectivity information does not have to be recalculated)
   integer(IntKi),                    intent(  out)  :: ErrStat     !< Error status of the operation
   character(*),                      intent(  out)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None


      ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ""

      ! Compute outputs here:
   y%DummyOutput    = 2.0_ReKi
   y%WriteOutput(1) = REAL(t,ReKi)
   y%WriteOutput(2) = 1.0_ReKi

end subroutine DirtDyn_CalcOutput


END MODULE DirtDyn

!**********************************************************************************************************************************
!NOTE: the following have been omitted.  When we add the other methods for calculating (6x6 Stiffness/Damping) and the P-Y curve, then
!      some of these will need to be added.  Leaving this as a placeholder for the moment.
!SUBROUTINE DirtDyn_CalcContStateDeriv( t, u, p, x, xd, z, OtherState, m, dxdt, ErrStat, ErrMsg )
!SUBROUTINE DirtDyn_UpdateDiscState( t, n, u, p, x, xd, z, OtherState, m, ErrStat, ErrMsg )
!SUBROUTINE DirtDyn_CalcConstrStateResidual( t, u, p, x, xd, z, OtherState, m, Z_residual, ErrStat, ErrMsg )
!SUBROUTINE DirtDyn_JacobianPInput( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg, dYdu, dXdu, dXddu, dZdu)
!SUBROUTINE DirtDyn_JacobianPContState( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg, dYdx, dXdx, dXddx, dZdx )
!SUBROUTINE DirtDyn_JacobianPDiscState( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg, dYdxd, dXdxd, dXddxd, dZdxd )
!SUBROUTINE DirtDyn_JacobianPConstrState( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg, dYdz, dXdz, dXddz, dZdz )
!SUBROUTINE DirtDyn_GetOP( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg, u_op, y_op, x_op, dx_op, xd_op, z_op )
